;;; mistty-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from mistty.el

(autoload 'mistty "mistty" "\
Go to the next MisTTY buffer, or create a new one.

The first time this command is called, it creates a new MisTTY
buffer. Afterwards, this command goes to a MisTTY buffer. If
already on a MisTTY buffer, go to the next one or create another
one.

If called with an argument, create a new buffer unconditionally,
so you can call `mistty' multiple times to visit existing MisTTY
buffers, and then, if it turns out to be necessary, call it a
final time with an argument to create a new one.

When creating a new buffer, the `default-directory' of that
buffer is taken from the buffer from which the chain of calls
`mistty' was started.

If OTHER-WINDOW is nil, execute the default action configured by
`display-comint-buffer-action'. If OTHER-WINDOW is a function, it is
passed to `pop-to-buffer` to be used as a `display-buffer' action.
Otherwise, display the buffer in another window.

    You might prefer configuring `display-buffer-alist' for
    comint category buffers to get the exact behavior you want instead
    of passing OTHER-WINDOW.

Passing ACCEPT-BUFFER is deprecated. Call `mistty-cycle-or-create'
instead. See that function for details on that argument.

    This function is for interactive use only. When building similar
    commands, call `mistty-cycle-or-create' instead.

(fn &optional OTHER-WINDOW ACCEPT-BUFFER)" t)
(autoload 'mistty-other-window "mistty" "\
Go to the next MisTTY buffer in another window.

    You might prefer configuring `display-buffer-alist' for
    comint category buffers and calling `mistty' directly to get
    the exact behavior you want instead of using
    `mistty-other-window'.

    This function is for interactive use only. When building similar
    commands, consider calling `mistty-cycle-or-create' instead." t)
(autoload 'mistty-create "mistty" "\
Create a new MisTTY buffer, running a shell.

The shell that is run can be configured by setting
`mistty-shell-command', `explicit-shell-file-name',
`shell-file-name' or come implicitly from the ESHELL or SHELL
environment variables.

Set COMMAND to specify instead the command to run for the current
call. COMMAND can be either a string or a list. If it is a
string, it should be the name of an executable to run, without
arguments. If it is a string, it should be a list of executable
and its arguments.

If this command is called with no prefix arg, it is executed in
the `default-directory' of the current buffer. If that directory
is a remote file, and if the TRAMP method supports it, the
command is executed on the remote host. This also works for
same-host methods, such as sudo. See Info node `(mistty)Remote
Shells with TRAMP' for details.

If this command is called with a prefix arg, it asks for the
value of `default-directory'. This is useful if you want start a
shell to a remote host without opening a file first.

If OTHER-WINDOW is nil, execute the default action configured by
`display-comint-buffer-action'. If OTHER-WINDOW is a function, it
is passed to `pop-to-buffer` to be used as a `display-buffer'
action. Otherwise, display the buffer in another window.

Upon success, the function returns the newly-created buffer.

(fn &optional COMMAND OTHER-WINDOW)" t)
(autoload 'mistty-create-other-window "mistty" "\
Create a new MisTTY buffer, running a shell, in another window.

If this command is called with no prefix arg, it is executed in
the `default-directory' of the current buffer. If that directory
is a remote file, and if the TRAMP method supports it, the
command is executed on the remote host. This also works for
same-host methods, such as sudo. See Info node `(mistty)Remote
Shells with TRAMP' for details.

If this command is called with a prefix arg, it asks for the
value of `default-directory'. This is useful if you want start a
shell to a remote host without opening a file first.

COMMAND, if specified, is the command to execute instead of the
shell.

See the documentation of `mistty-create' for details.

(fn &optional COMMAND)" t)
(register-definition-prefixes "mistty" '("mistty-"))


;;; Generated autoloads from mistty-changeset.el

(register-definition-prefixes "mistty-changeset" '("mistty--"))


;;; Generated autoloads from mistty-launch.el

(autoload 'mistty-ssh "mistty-launch" "\
Open SSH running on HOST in a MisTTY buffer.

This is a convenience function that uses TRAMP to connect to a
host and open a shell to it. For more control, run
C-u \\[mistty-create]. That'll allow you to setup any TRAMP
remote path you'd like without restrictions.

See Info Node `(mistty)Remote Shells with TRAMP' for more
details.

(fn &optional HOST COMMAND OTHER-WINDOW)" t)
(autoload 'mistty-docker "mistty-launch" "\
Connect to a docker instance in a MisTTY buffer.

This is a convenience function that uses TRAMP to connect to a
host and open a shell to it. For more control, run
C-u \\[mistty-create]. That'll allow you to setup any TRAMP
remote path you'd like without restrictions.

See Info Node `(mistty)Remote Shells with TRAMP' for details.

Note that docker instances often run older versions of Bash;
MisTTY will work on Bash versions < 5.1, with some limitations.
Additionally, for Bash 4.3 and earlier, you might have to set
`mistty-set-EMACS' to non-nil for directory tracking to work. You
can set it per instance as a connection-local variable. See Info
Anchor `(mistty)shells bash-dirtrack' for details.

(fn &optional INSTANCE COMMAND OTHER-WINDOW)" t)
(register-definition-prefixes "mistty-launch" '("mistty-"))


;;; Generated autoloads from mistty-log.el

(register-definition-prefixes "mistty-log" '("mistty-"))


;;; Generated autoloads from mistty-osc-colors.el

(register-definition-prefixes "mistty-osc-colors" '("mistty-osc-query-color"))


;;; Generated autoloads from mistty-osc7.el

(register-definition-prefixes "mistty-osc7" '("mistty-"))


;;; Generated autoloads from mistty-project.el

(autoload 'mistty-in-project "mistty-project" "\
Start or go to a MisTTY buffer in the project's root directory.

If a MisTTY buffer already exists for running a shell in the
project's root, switch to it. If we're already on that buffer,
create a new buffer in that project, like `mistty' does.

Otherwise, create a new MisTTY shell buffer. With
\\[universal-argument] prefix arg, create a new shell buffer even
if one already exists.

If OTHER-WINDOW is nil, execute the default action configured by
`display-comint-buffer-action' to pop to the existing or newly-created
buffer. If OTHER-WINDOW is a function, it is passed to `pop-to-buffer`
to be used as a `display-buffer' action. Otherwise, display the buffer
in another window.

    You might prefer configuring `display-buffer-alist' for
    comint category buffers to get the exact behavior you want
    instead of passing OTHER-WINDOW.

(fn &optional OTHER-WINDOW)" t)
(register-definition-prefixes "mistty-project" '("mistty-"))


;;; Generated autoloads from mistty-queue.el

(register-definition-prefixes "mistty-queue" '("mistty-"))


;;; Generated autoloads from mistty-term.el

(register-definition-prefixes "mistty-term" '("mistty-"))


;;; Generated autoloads from mistty-undo.el

(register-definition-prefixes "mistty-undo" '("mistty--"))


;;; Generated autoloads from mistty-util.el

(register-definition-prefixes "mistty-util" '("mistty-"))

;;; End of scraped data

(provide 'mistty-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; mistty-autoloads.el ends here
